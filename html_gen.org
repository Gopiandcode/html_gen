* HtmlGen
A simple little static templating engine for HTML.
Coded using literate programming.


* Preamble
While the overall nature of this project is quite simple - just a
bit of file loading and exports, we can leverage rust's ecosystem
to make our development a little easier.

** Crates
The crates we'll be using are as follows:
- *ArgParse* - This is a crate that I used a while back when making
another command line application. It provides a very nice rustic
interface over a library which produces command line interfaces
compliant with most unix/linux standards.

#+begin_src rust :tangle src/main.rs  :comments both
extern crate argparse;
#+end_src

** Standard Library Imports
We'll be using the path utilities provided by the standard library to help us navigate the filesystem in a cross platform way.
#+begin_src rust :tangle src/main.rs :comments both
use std::path;
#+end_src
** Module structure
We'll be splitting up our codebase as follows:

#+begin_src rust :tangle src/main.rs :noweb yes :comments both
<<modules>>
#+end_src


* Command Line Interface
Clearly this project is going to be a command line application, as the static generator will need to parse through a document
and construct the components.

Using argparse - as imported in the preamble, we'll design a sweet
and sexy interface to access our application.
The main actions we'll allow a user to perform using this application
will be as follows:
- *specify output folder* - by default the output of the compiled files
are placed in ~./bin/~ dir, which is made if it does not exist.
- *specify template folder* - within a non-templated file, when
 a template reference is used, by default the application searches the 
 ~./template/~ dir to resolve these references.
- *specify input folder* - by default the program searches ~./src/~ for templated files to be 

#+begin_src rust :tangle src/main.rs :comments both
fn main() {
#+end_src
Now, as specified, our output and template paths take default values from where the application was instantiated.
#+begin_src rust :tangle src/main.rs :comments both
    let mut output_path = String::from("./bin");
    let mut template_path = String::from("./template");
    let mut input_path = String::from("./src");
#+end_src


Using argparse, we can implement this cmdline interface as follows:
#+begin_src rust :tangle src/main.rs :comments both
    {
        let mut ap = argparse::ArgumentParser::new();
        ap.set_description("Simple templating engine for html documents");
        ap.refer(&mut output_path)
        .add_option(&["-o","--output"], argparse::Store, "directory for the output files to be saved");

        ap.refer(&mut template_path)
        .add_option(&["-t","--template"], argparse::Store, "directory to be searched to find templates");

        ap.refer(&mut input_path)
        .add_option(&["-i","--input"], argparse::Store, "directory in which the source files to be compiled are located");


        ap.parse_args_or_exit();
    }
#+end_src

* Core Logic
Now we've obtained the directory for the files to be stored, we can move on to the main logic of the program.
Fundamentaly the logic of this program can be split into two main components:
 - Recursively descending the source directory, keeping track of the file structure.
#+name: modules 
#+begin_src rust
mod parser;
#+end_src
 - Extracting the data from a given file, using it to populate a compiled file
#+name: modules 
#+begin_src rust 
mod crawler;
#+end_src
** Parser Logic


#+begin_src rust :tangle src/main.rs  :comments both
}
#+end_src

